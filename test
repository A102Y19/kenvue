import os
import sys
import time
import re
import logging
import subprocess
import pyautogui
import pyperclip
import pygetwindow as gw
import pandas as pd
import win32gui
import datetime
from pathlib import Path
import textwrap
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from pywinauto import Application, findwindows
from pyautogui import getWindowsWithTitle
from pywinauto.keyboard import send_keys
from dotenv import load_dotenv
from pywinauto import Desktop
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders

# Get password from environment variable
#password = os.getenv("OMP_pass")
#if not password:
#    logging.error("Error: Environment variable 'OMP_pass' not found!")
#    sys.exit(1)

NETWORK_DIR = Path(r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\log")
timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
log_filename = NETWORK_DIR / f"log_{timestamp}.txt"


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_filename),
        logging.StreamHandler()
    ]
)

def count_cmd_windows():
    try:
        return len([
            w for w in findwindows.find_windows()
            if "cmd.exe" in win32gui.GetWindowText(w).lower() or
            "command prompt" in win32gui.GetWindowText(w).lower()
        ])
    except exception as e:
        logging.error(f"Error counting CMD windows: {e}")
        return 0


def launch_cmd_as_admin_and_run():


# === DB CONFIG ===
 DB_USER = "PAKDB_USER"
DB_PASS = os.getenv('db_key')
DB_TNS = "DNV16001"
DB_USER = "PAKDB_USER"

# === NETWORK LOG DIRECTORY ===

COMMAND_LOG = log_filename 
SERVERS_FILE = NETWORK_DIR / "servers.txt"
SQL_SCRIPT_PATH = Path("temp_command_script.sql")

# === SQL COMMANDS ===

sql_commands = textwrap.dedent(f"""\
    SET ECHO ON;
    SET TERMOUT ON;
    WHENEVER SQLERROR EXIT SQL.SQLCODE;

    ALTER SESSION SET NLS_DATE_FORMAT='DD/MM/YYYY HH24:MI:SS';
    SET HEADING OFF;
    SET FEEDBACK OFF;
    SET PAGES 0;

    SPOOL '{COMMAND_LOG}';
    SELECT SYSDATE FROM DUAL;
    SELECT MAX(SEQUENCE#) AS LAST_GENERATED_SEQUENCE FROM V$ARCHIVED_LOG;
    SET SERVEROUTPUT ON;
    BEGIN
        pakuser_switch_logfile;
    END;
    /
    SELECT MAX(SEQUENCE#) AS LAST_GENERATED_SEQUENCE FROM V$ARCHIVED_LOG;
    SELECT SYSDATE FROM DUAL;
    SELECT COUNT(1) FROM v$session WHERE username LIKE 'OMP_JNJ_CMD_OPTMS_LAB_%';
    SET LINES 200;
    COL username FOR A30;
    COL osuser FOR A30;
    COL machine FOR A30;
    SELECT username, osuser, machine, COUNT(*) 
    FROM v$session 
    WHERE username LIKE 'OMP_JNJ_CMD_OPTMS_LAB_%' 
    GROUP BY username, osuser, machine 
    ORDER BY username, osuser, machine;
    SPOOL OFF;

    SET PAGES 0;
    SET HEADING OFF;
    SET FEEDBACK OFF;
    SPOOL '{SERVERS_FILE}';
    SET LINES 200;
    COL username FOR A30;
    COL osuser FOR A30;
    COL machine FOR A30;
    SELECT username, osuser, machine, COUNT(*) 
    FROM v$session 
    WHERE username LIKE 'OMP_JNJ_CMD_OPTMS_LAB_%' 
    GROUP BY username, osuser, machine 
    ORDER BY username, osuser, machine;
    SPOOL OFF;

    EXIT;
""")


# === WRITE TEMP SQL SCRIPT ===
SQL_SCRIPT_PATH.write_text(sql_commands)

# === EXECUTE SQLPLUS AND CAPTURE OUTPUT ===
logging.info(" Running SQL*Plus commands with full output...")

with open("sqlplus_stdout.txt", "w") as stdout_log, open("sqlplus_stderr.txt", "w") as stderr_log:
    subprocess.run(
        f'sqlplus -s {DB_USER}/{DB_PASS}@{DB_TNS} @{SQL_SCRIPT_PATH}',
        shell=True,
        text=True,
        stdout=stdout_log,
        stderr=stderr_log
    )

# === CLEANUP TEMP FILE ===
SQL_SCRIPT_PATH.unlink(missing_ok=True)

# === FINAL FEEDBACK ===
logging.info(" SQL commands executed.")
logging.info(f" Main log written to       {COMMAND_LOG}")
logging.info(f"  Server list written to   {SERVERS_FILE}")
logging.info(f" STDOUT log  sqlplus_stdout.txt")
logging.info(f" STDERR log  sqlplus_stderr.txt")




def remove_active_users():
    logging.info("Removing active users script execution started")

    try:
        result = subprocess.run(
            ["powershell", "-ExecutionPolicy", "Bypass", "-File",
             r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\Remove_Active_Users2.ps1"], 
            check=True,
            capture_output=True,
            text=True
        )
        with open(log_filename, "a") as f:
            f.write(result.stdout)
            f.write(result.stderr)
        logging.info("All active users removed successfully")

    except subprocess.CalledProcessError as e:
        logging.error(f"Active user removal failed with return code {e.returncode}")
        logging.error(f"STDOUT: {e.stdout}")
        logging.error(f"STDERR: {e.stderr}")
        raise  # Stop the script if PowerShell fails

    time.sleep(10)
	
def eventmonitor_server_stop():
    logging.info("Stop Event Monitor server script execution started")

    try:
        result = subprocess.run(
            ["powershell", "-ExecutionPolicy", "Bypass", "-File",
             r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\Event_Monitor_server.ps1"], 
            check=True,
            capture_output=True,
            text=True
        )
        with open(log_filename, "a") as f:
            f.write(result.stdout)
            f.write(result.stderr)
        logging.info("Event Monitor stopped successfully")

    except subprocess.CalledProcessError as e:
        logging.error(f"Active user removal failed with return code {e.returncode}")
        logging.error(f"STDOUT: {e.stdout}")
        logging.error(f"STDERR: {e.stderr}")
        raise  # Stop the script if PowerShell fails

    time.sleep(10)

def stop_omp_integrator(path):
    try:
        
        filename = f"StopUploadServer{timestamp}.rqs"
        file_path = os.path.join(path, filename)

        with open(file_path, "w") as f:
            f.write("")  # Empty content; add specific content if needed

        logging.info(f"'{filename}' created at: {file_path}")

    except Exception as e:
        logging.error(f"Failed to create file: {e}")
	
def launching_OMP():
    script_path = r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\bin\OMPartners_menu.cmd"  # Replace with actual script name

    try:
        if os.path.exists(script_path):
            # Try launching the script
            logging.info(f"Launching OMP application from: {script_path}")
            subprocess.Popen(script_path, shell=True)
            
            logging.info("OMP application launch Initiated.")
            time.sleep(20)
        
            

            # Check if OMP Plus is already running
            omp_app = None
            for _ in range(5):
                try:
                    windows = findwindows.find_windows(title_re=".*OMP.*", backend='win32')
                    if windows:
                        omp_app = Application().connect(handle=windows[0])
                        logging.info("OMP Plus application detected.")
                        break
                except Exception as e:
                    logging.info("OMP Plus not running yet, retrying...")
                time.sleep(10)

            if not omp_app:
                logging.error("OMP Plus did not launch!")
                exit(1)

            return omp_app

    except Exception as e:
        logging.error(f"Unexpected error: {e}")

def stop_dispatcher(dispatcher_path):
# Path to your script folder
	
	
	# Command to run
	cmd = "DispatcherManagementAction.cmd stop /all"
	
	# Full command
	full_command = f'pushd {dispatcher_path} && {cmd}'
	
	# Run the command in CMD
	process = subprocess.run(full_command, shell=True, text=True)
	
	# Optional: check return code
	if process.returncode == 0:
		logging.info("Dispatcher stopped successfully.")
	else:
		logging.info("Failed to stop Dispatcher.") 


def industry_solution_build(omp_app):
    try:
        max_retries = 2  # Maximum number of retries
        attempt = 0

        while attempt <= max_retries:
            attempt += 1
            logging.info(f"Attempt {attempt} of {max_retries}...")

            omp_window = omp_app.top_window()
            omp_window.set_focus()
            time.sleep(1)

            logging.info("Sending Alt + U...")
            omp_window.type_keys('%u')
            time.sleep(2)
            logging.info("Sending C...")
            omp_window.type_keys('C')
            time.sleep(2)
            logging.info("Sending C...")
            omp_window.type_keys('C')
            time.sleep(2)
            logging.info("Sending U...")
            omp_window.type_keys('U')
            time.sleep(2)
            logging.info("Sending LEFT...")
            send_keys("{LEFT}")
            time.sleep(2)
            logging.info("Sending U...")
            omp_window.type_keys('U')
            time.sleep(2)
            logging.info("Sending DOWN...")
            send_keys("{DOWN 3}")
            time.sleep(2)
            logging.info("Sending ENTER...")
            send_keys("{ENTER}")
            logging.info("Initiated Installing Industry solution Build.")
            time.sleep(30)

            logging.info("Waiting for OMP Data Change Manager to launch...")
            time.sleep(10)

            # Check if 'OMP Data Change Manager' window opened
            window_found = False
            for _ in range(3):  # Retry a few times within this attempt
                try:
                    windows = findwindows.find_windows(title_re=".*OMP Data Change Manager.*", backend='win32')
                    if windows:
                        logging.info("OMP Data Change Manager window detected.")
                        window_found = True
                        break
                    time.sleep(15)
                except Exception:
                    logging.info("Waiting for window...")

                time.sleep(10)

            if window_found:
                logging.info("OMP Data Change Manager launched successfully.")
                break  # Exit retry loop if successful
            else:
                logging.error("OMP Data Change Manager did not open. Retrying...")
                if attempt == max_retries:
                    logging.error("Maximum retries reached. Exiting...")
                    sys.exit(1)

    except Exception as e:
        logging.error(f"Error during project Solution Build: {e}")
		

		

def proejct_solution_build(omp_app):
    try:
        max_retries = 2  # Maximum number of retries
        attempt = 0

        while attempt <= max_retries:
            attempt += 1
            logging.info(f"Attempt {attempt} of {max_retries}...")

            omp_window = omp_app.top_window()
            omp_window.set_focus()
            time.sleep(1)

            logging.info("Sending Alt + U...")
            omp_window.type_keys('%u')
            time.sleep(2)
            logging.info("Sending C...")
            omp_window.type_keys('C')
            time.sleep(2)
            logging.info("Sending C...")
            omp_window.type_keys('C')
            time.sleep(2)
            logging.info("Sending U...")
            omp_window.type_keys('U')
            time.sleep(2)
            logging.info("Sending LEFT...")
            send_keys("{LEFT}")
            time.sleep(2)
            logging.info("Sending U...")
            omp_window.type_keys('U')
            time.sleep(2)
            logging.info("Sending DOWN...")
            send_keys("{DOWN 4}")
            time.sleep(2)
            logging.info("Sending ENTER...")
            send_keys("{ENTER}")
            logging.info("Initiated Installing project solution Build.")
            time.sleep(30)

            logging.info("Waiting for OMP Data Change Manager to launch...")
            time.sleep(10)

            # Check if 'OMP Data Change Manager' window opened
            window_found = False
            for _ in range(3):  # Retry a few times within this attempt
                try:
                    windows = findwindows.find_windows(title_re=".*OMP Data Change Manager.*", backend='win32')
                    if windows:
                        logging.info("OMP Data Change Manager window detected.")
                        window_found = True
                        break
                    time.sleep(15)
                except Exception:
                    logging.info("Waiting for window...")

                time.sleep(10)

            if window_found:
                logging.info("OMP Data Change Manager launched successfully.")
                break  # Exit retry loop if successful
            else:
                logging.error("OMP Data Change Manager did not open. Retrying...")
                if attempt == max_retries:
                    logging.error("Maximum retries reached. Exiting...")
                    sys.exit(1)

    except Exception as e:
        logging.error(f"Error during project Solution Build: {e}")
		

def schema_pass():
    load_dotenv(r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\.env")
    
    schema_keys = [
        "OMP_JNJ_CMD_OPTMS_LAB_OPR",
        "OMP_JNJ_CMD_OPTMS_LAB_FCT",
        "OMP_JNJ_CMD_OPTMS_LAB_UTL"
    ]

    for key in schema_keys:
        schema_password = os.getenv(key)
        if not schema_password:
            logging.info(f"password not found for {key}")
            continue

        time.sleep(10)
        pyautogui.write(schema_password)
        time.sleep(2)
        pyautogui.press("enter")
        logging.info(f"Entered password for {key}")
    
    time.sleep(20)
#    logging.info("Sending DOWN...")
#    send_keys("{DOWN}")
#    time.sleep(2)
    logging.info("sending TAB Twice")
    send_keys("{TAB}{TAB}")
    time.sleep(2)
    logging.info("Sending UP...")
    send_keys("{UP 2}")
    time.sleep(2)
    logging.info("Sending ENTER...")
    send_keys("{ENTER}")
    time.sleep(10)

# --------------------------------------------------------
# Helper: detect OMP window using both backends + regex
# --------------------------------------------------------
def find_omp_window():
    for backend in ["uia", "win32"]:
        try:
            windows = Desktop(backend=backend).windows()
            for win in windows:
                title = win.window_text().strip()
                if re.search(r"OMP\s*Data\s*Change\s*Manager", title, re.IGNORECASE):
                    logging.info(f"OMP window found using backend={backend} | title={title}")
                    return win
        except Exception as e:
            logging.warning(f"Window scan failed (backend={backend}): {e}")
            continue
    return None

# --------------------------------------------------------
# Helper: check if window handle is still valid
# --------------------------------------------------------
def is_window_valid(win):
    try:
        _ = win.element_info.name
        return True
    except Exception:
        return False

# --------------------------------------------------------
# Helper: continuously get a valid OMP window
# --------------------------------------------------------
def get_stable_omp_window(max_retries=15, wait_sec=5):
    omp_window = None
    for attempt in range(max_retries):
        omp_window = find_omp_window()
        if omp_window:
            time.sleep(2)
            if is_window_valid(omp_window):
                logging.info(f"Stable OMP window detected (attempt {attempt+1})")
                return omp_window
        logging.info(f"OMP window not detected (attempt {attempt+1}/{max_retries}). Retrying in {wait_sec}s...")
        time.sleep(wait_sec)
    logging.error("Failed to detect OMP Data Change Manager window after multiple retries.")
    return None

# --------------------------------------------------------
# Main function: wait for Update Installer & Information
# --------------------------------------------------------
def wait_for_update_installer_and_information():
    logging.info("Starting OMP monitoring process...")

    omp_window = get_stable_omp_window()
    if not omp_window:
        logging.warning("OMP Data Change Manager not found. Proceeding without window reference.")
        return

    # --- Step 2: Wait for 'Update Installer' ---
    logging.info("Looking for 'Update Installer' in OMP window...")
    update_installer_found = False
    for attempt in range(6):  # check 6 times (about 1 minute total)
        if not is_window_valid(omp_window):
            omp_window = get_stable_omp_window()
            if not omp_window:
                break

        try:
            panes = omp_window.descendants()
            for pane in panes:
                name = pane.element_info.name
                text = pane.window_text()
                if "update installer" in name.lower() or "update installer" in text.lower():
                    logging.info(f"'Update Installer' detected on attempt {attempt+1}")
                    update_installer_found = True
                    break
            if update_installer_found:
                break
        except Exception as e:
            logging.warning(f"Error checking Update Installer: {e}")
        logging.info(f"Update Installer not found. Retrying in 10s... (Attempt {attempt+1}/6)")
        time.sleep(10)

    if not update_installer_found:
        logging.info("Update Installer not found after all retries. Continuing...")

    # --- Step 3: Wait for 'Information' popup ---
    # Wait for 'Information' popup and handle it
    logging.info("Waiting for 'Information' popup every 60 seconds...")
    while True:
        try:
            panes = omp_window.descendants()
            for pane in panes:
                try:
                    name = pane.element_info.name
                    text = pane.window_text()
                    if "Information" in name or "Information" in text:
                        logging.info(f"'Information' popup found: {text}")
                        pyautogui.press('enter')
                        logging.info("ENTER sent to close popup.")

                        # Check for Notepad after ENTER
                        notepad_found = False
                        start_time = time.time()
                        timeout = 60

                        while time.time() - start_time < timeout:
                            windows = Desktop(backend="uia").windows()
                            for win in windows:
                                if "Notepad" in win.window_text():
                                    logging.info("Notepad window found.")
                                    notepad_found = True
                                    handle_notepad_if_opened(win)
                                    break
                            if notepad_found:
                                break
                            time.sleep(5)
                            
                        if not notepad_found:
                            logging.info("Installation completed. No Notepad found.")
                            time.sleep(60)
                        return
                except Exception as info_error:
                    logging.warning(f"Error checking Information pane: {info_error}")
                    sys.exit("Exiting script due to error in checking Information pane.")
        except Exception as e:
            logging.error(f"Error while checking for Information popup: {e}")
            sys.exit("Exiting script due to error while checking Information popup.")
        time.sleep(60)

		
def handle_notepad_if_opened(notepad_window):
    
        notepad_window.set_focus()
        time.sleep(1)
        pyautogui.hotkey("ctrl", "a")
        time.sleep(1)
        pyautogui.hotkey("ctrl", "c")
        time.sleep(1)
        copied_text = pyperclip.paste()

        # Open a new Notepad
        subprocess.Popen(["notepad.exe"])
        time.sleep(2)
        pyautogui.hotkey("ctrl", "v")
        time.sleep(2)

        # Save file in log as failed_logs.txt
        failed_file = r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\log\failed_logs_" + time.strftime("%Y-%m-%d_%H-%M-%S") + ".txt"
        pyautogui.hotkey("ctrl", "s")
        time.sleep(2)
        pyautogui.write(failed_file)
        time.sleep(2)
        pyautogui.press("enter")
        time.sleep(2)

        logging.info(f" Installation failed logs copied and saved to {failed_file}")

        #  Send email with failed log
        send_email(
            subject="OMP Deployment FAILED",
            body="Deployment failed. Please check attached logs.",
            file_path=failed_file
        )

        try:
            subprocess.run("taskkill /IM notepad.exe /F", shell=True)
            time.sleep(10)
            pyautogui.hotkey("ENTER")
            logging.info("Closed all Notepad instances.")
        except Exception as e:
            logging.error(f"Failed to close Notepads: {e}")

        sys.exit()

#validate Version details
def validate_version_details(file_path, expected_version):
    try:
        if not os.path.exists(file_path):
            logging.error(f"[ERROR] File not found: {file_path}")
            sys.exit(1)

        with open(file_path, 'r') as f:
            content = f.read()

        if expected_version in content:
            logging.info(f"[SUCCESS] Version '{expected_version}' found in {file_path}")
        else:
            logging.info(f"[ERROR] Version '{expected_version}' NOT found in {file_path}")
            sys.exit(1)

    except Exception as e:
        logging.info(f"[EXCEPTION] Failed to validate version details: {str(e)}")    
        sys.exit(1)

def start_omp_integrator(path):
    try:
        
        filename = f"StartUploadServer{timestamp}.rqs"
        file_path = os.path.join(path, filename)

        with open(file_path, "w") as f:
            f.write("")  # Empty content; add specific content if needed

        logging.info(f"'{filename}' created at: {file_path}")
    except Exception as e:
        logging.error(f"Failed to create file: {e}")		

def send_email(subject, body, file_path):
    try:
        from_addr = "gyellap1@its.jnj.com"          
        to_addrs = ["gyellap1@its.jnj.com"]         
        smtp_server = "SMTP.EU.JNJ.com"              #  your SMTP relay
        smtp_port = 25                               # mostly 25 or 587

        msg = MIMEMultipart()
        msg["From"] = from_addr
        msg["To"] = ", ".join(to_addrs)
        msg["Subject"] = subject
        msg.attach(MIMEText(body, "plain"))

        if os.path.exists(file_path):
            with open(file_path, "rb") as f:
                part = MIMEBase("application", "octet-stream")
                part.set_payload(f.read())
                encoders.encode_base64(part)
                part.add_header(
                    "Content-Disposition",
                    f"attachment; filename={os.path.basename(file_path)}",
                )
                msg.attach(part)

        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.sendmail(from_addr, to_addrs, msg.as_string())

        logging.info(f" Email sent successfully with {file_path}")
    except Exception as e:
        logging.error(f" Failed to send email: {e}")


def main_launcher():
    excel_file = r"\\awsusdmlfsxn01.jnj.com\opt_pdev3_omp_na\OMP_JNJ_CMD_OPTMS_LAB\OMPartners\development\dispatcher\bin\Automation\PAK\PAK_Standard_requirement.xlsx"
    try:
        df = pd.read_excel(excel_file, sheet_name=1)
    except Exception as e:
        logging.info(f"Failed to load Excel: {e}")
        return

    omp_app = None
    result = None

    for index, row in df.iterrows():
        action = str(row.iloc[0]).strip().lower()
        requirement = str(row.iloc[1]).strip().upper()
        inputs = str(row["Inputs"]).strip()

        if requirement == "Y":
            #if "eventmonitor server stop" in action:
             #   logging.info("Executing Eventmonitor Server Stop")
                #  eventmonitor_server_stop(key_word=inputs)

            if "stop omp integrator" in action:
                logging.info("Executing to stop integrator upload server job")
                stop_omp_integrator(inputs)

            elif "launch omp" in action:
                logging.info("Launching OMP")
                omp_app = launching_OMP()

            elif "stop dispatcher" in action:
                logging.info("Executing Stop Dispatcher")
                dispatcher_path = str(row.iloc[2]).strip()
                stop_dispatcher(dispatcher_path)

            elif "project build" in action:
                logging.info("Executing Project Build")
                if omp_app:
                    proejct_solution_build(omp_app)

            elif "industry build" in action:
                logging.info("Executing Industry Build")
                if omp_app:
                    industry_solution_build(omp_app)

            elif "schema pass" in action:
                logging.info("Executing Schema Pass")
                schema_pass()
                wait_for_update_installer_and_information()

                if result is True:
                    logging.info("Schema execution SUCCESS")
                elif result is False:
                    logging.info("Schema execution FAILED")
                else:
                    logging.info("Schema execution STATUS UNKNOWN")

            elif "validate version details" in action:
                try:
                    path, version = map(str.strip, inputs.split(','))
                    validate_version_details(path, version)
                except ValueError:
                    logging.error("Invalid input format for version validation. Expected: 'path, version'.")

            elif "start omp integrator" in action:
                logging.info("Executing to start integrator upload server job")
                start_omp_integrator(inputs)

            else:
                logging.info(f"Unknown action '{action}', skipping...")
        else:
            logging.info(f"Skipping '{action}' as requirement is N")
			
			
if __name__ == "__main__":
    #launch_cmd_as_admin_and_run()
    #remove_active_users()
    #eventmonitor_server_stop()
    main_launcher()
    send_email(
        subject="OMP Deployment SUCCESS",
        body="Deployment completed successfully with Automation. Please check attached logs.",
        file_path=str(log_filename)
    )

    
